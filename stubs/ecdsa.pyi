from typing import Any, Callable, List, Optional, Tuple, Type, Union, overload
import hashlib
import six

class BadSignatureError(Exception): ...
class BadDigestError(Exception): ...

class PRNG:
    @classmethod
    def get_random_number_generator(cls) -> "PRNG": ...
    def __init__(self, seed: Optional[bytes] = None) -> None: ...
    def __call__(self, limit: int) -> int: ...


class Curve:
    name: str
    openssl_name: Optional[str]
    baselen: int
    
    @property
    def G(self) -> "Point": ...
    @property
    def generator(self) -> "generator.Generator": ...
    @property
    def order(self) -> int: ...
    @property
    def n(self) -> int: ...
    @property
    def p(self) -> int: ...
    @property
    def a(self) -> int: ...
    @property
    def b(self) -> int: ...
    @property
    def bits(self) -> int: ...
    
    def contains_point(self, x: int, y: int) -> bool: ...


class Point:
    def __init__(self, curve: Curve, x: int, y: int, order: Optional[int] = None) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __add__(self, other: "Point") -> "Point": ...
    def __mul__(self, scalar: int) -> "Point": ...
    def __rmul__(self, scalar: int) -> "Point": ...
    def double(self) -> "Point": ...


class PointJacobi:
    def __init__(self, curve: Curve, x: int, y: int, z: int, order: Optional[int] = None) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __add__(self, other: "PointJacobi") -> "PointJacobi": ...
    def __mul__(self, scalar: int) -> "PointJacobi": ...
    def __rmul__(self, scalar: int) -> "PointJacobi": ...
    def double(self) -> "PointJacobi": ...


class CurveFp(Curve):
    def __init__(self, p: int, a: int, b: int, n: int, gx: int, gy: int, name: str, 
                 oid: Optional[List[int]] = None, openssl_name: Optional[str] = None) -> None: ...


class NIST192p(CurveFp): ...
class NIST224p(CurveFp): ...
class NIST256p(CurveFp): ...
class NIST384p(CurveFp): ...
class NIST521p(CurveFp): ...
class SECP256k1(CurveFp): ...


class SigningKey:
    @classmethod
    def generate(cls, curve: Curve = NIST192p, entropy: Optional[Callable[[int], bytes]] = None, 
                hashfunc: Optional[Callable[[bytes], Any]] = None) -> "SigningKey": ...
    
    @classmethod
    def from_secret_exponent(cls, secexp: int, curve: Curve = NIST192p, 
                            hashfunc: Optional[Callable[[bytes], Any]] = None) -> "SigningKey": ...
    
    @classmethod
    def from_string(cls, string: bytes, curve: Curve = NIST192p, 
                  hashfunc: Optional[Callable[[bytes], Any]] = None) -> "SigningKey": ...
    
    @classmethod
    def from_pem(cls, string: Union[bytes, str], hashfunc: Optional[Callable[[bytes], Any]] = None) -> "SigningKey": ...
    
    @classmethod
    def from_der(cls, string: bytes, hashfunc: Optional[Callable[[bytes], Any]] = None) -> "SigningKey": ...
    
    def __init__(self, _error_do_not_use_init: Any = None) -> None: ...
    def get_verifying_key(self) -> "VerifyingKey": ...
    def sign_deterministic(self, data: bytes, hashfunc: Optional[Callable[[bytes], Any]] = None,
                         sigencode: Callable[..., Any] = None, extra_entropy: Optional[bytes] = None) -> bytes: ...
    
    def sign(self, data: bytes, entropy: Optional[Callable[[int], bytes]] = None,
           sigencode: Callable[..., Any] = None) -> bytes: ...
    
    def sign_digest(self, digest: bytes, entropy: Optional[Callable[[int], bytes]] = None,
                  sigencode: Callable[..., Any] = None) -> bytes: ...
    
    def sign_digest_deterministic(self, digest: bytes, hashfunc: Optional[Callable[[bytes], Any]] = None,
                                sigencode: Callable[..., Any] = None, extra_entropy: Optional[bytes] = None) -> bytes: ...
    
    def to_string(self) -> bytes: ...
    def to_pem(self, point_encoding: str = "uncompressed") -> bytes: ...
    def to_der(self, point_encoding: str = "uncompressed") -> bytes: ...


class VerifyingKey:
    @classmethod
    def from_string(cls, string: bytes, curve: Curve = NIST192p, 
                  hashfunc: Optional[Callable[[bytes], Any]] = None, 
                  validate_point: bool = True) -> "VerifyingKey": ...
    
    @classmethod
    def from_pem(cls, string: Union[bytes, str], hashfunc: Optional[Callable[[bytes], Any]] = None) -> "VerifyingKey": ...
    
    @classmethod
    def from_der(cls, string: bytes, hashfunc: Optional[Callable[[bytes], Any]] = None) -> "VerifyingKey": ...
    
    @classmethod
    def from_public_point(cls, point: Point, curve: Curve = NIST192p, 
                        hashfunc: Optional[Callable[[bytes], Any]] = None) -> "VerifyingKey": ...
    
    @classmethod
    def from_public_key_recovery(cls, signature: bytes, data: bytes, curve: Curve = NIST192p, 
                               hashfunc: Optional[Callable[[bytes], Any]] = None, 
                               sigdecode: Optional[Callable[..., Tuple[int, int]]] = None) -> List["VerifyingKey"]: ...
    
    @classmethod
    def from_public_key_recovery_with_digest(cls, signature: bytes, digest: bytes, curve: Curve = NIST192p, 
                                          sigdecode: Optional[Callable[..., Tuple[int, int]]] = None) -> List["VerifyingKey"]: ...
    
    def __init__(self, _error_do_not_use_init: Any = None) -> None: ...
    def verify(self, signature: bytes, data: bytes, hashfunc: Optional[Callable[[bytes], Any]] = None,
             sigdecode: Optional[Callable[..., Tuple[int, int]]] = None) -> bool: ...
    
    def verify_digest(self, signature: bytes, digest: bytes, 
                    sigdecode: Optional[Callable[..., Tuple[int, int]]] = None) -> bool: ...
    
    def to_string(self, encoding: str = "uncompressed") -> bytes: ...
    def to_pem(self, point_encoding: str = "uncompressed") -> bytes: ...
    def to_der(self, point_encoding: str = "uncompressed") -> bytes: ...


class BadSignatureError(Exception): ...


def int_to_string(x: int, orderlen: int) -> bytes: ...
def string_to_int(s: bytes) -> int: ...


class util:
    @staticmethod
    def randrange(order: int, entropy: Optional[Callable[[int], bytes]] = None) -> int: ...
    @staticmethod
    def randrange_from_seed__trytryagain(seed: bytes, order: int) -> Tuple[int, bytes]: ...


def sigencode_strings(r: int, s: int, order: Optional[int] = None) -> Tuple[bytes, bytes]: ...
def sigencode_string(r: int, s: int, order: Optional[int] = None) -> bytes: ...
def sigencode_der(r: int, s: int, order: Optional[int] = None) -> bytes: ...
def sigdecode_string(signature: bytes, order: Optional[int] = None) -> Tuple[int, int]: ...
def sigdecode_der(sig_der: bytes, order: Optional[int] = None) -> Tuple[int, int]: ...


class ellipticcurve:
    class CurveFp:
        def __init__(self, p: int, a: int, b: int) -> None: ...
        def contains_point(self, x: int, y: int) -> bool: ...
    
    class Point:
        def __init__(self, curve: CurveFp, x: int, y: int, order: Optional[int] = None) -> None: ...
        def __add__(self, other: "ellipticcurve.Point") -> "ellipticcurve.Point": ...
        def __mul__(self, scalar: int) -> "ellipticcurve.Point": ...
        def __rmul__(self, scalar: int) -> "ellipticcurve.Point": ...


class numbertheory:
    @staticmethod
    def inverse_mod(a: int, m: int) -> int: ...
    @staticmethod
    def square_root_mod_prime(a: int, p: int) -> int: ...